import asyncio
import websockets
import json
import base64
import cv2
import time
import sys
import os
import random
import logging
import gc
import subprocess
from picamera2 import Picamera2
from websockets.exceptions import ConnectionClosed
import serial
from datetime import datetime
from collections import deque

# Add Xeryon library path
sys.path.append('/home/pi/Desktop/RemoteDemoStation/BasicServer/Python')
from Xeryon import Xeryon, Stage, Units

# Set up logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Configuration
STATION_ID = "RPI1"
SERVER_URL = f"wss://xeryonremotedemostation.replit.app/rpi/{STATION_ID}"
RETRY_DELAY = 2
MAX_RETRIES = 5
SESSION_RETRIES = 3
RESOLUTION_WIDTH = 1280  # Reduced resolution
RESOLUTION_HEIGHT = 720  # Reduced resolution
JPEG_QUALITY = 50
TARGET_FPS = 15  # Reduced FPS
STALL_TIMEOUT = 300
COM_PORT = "/dev/ttyACM0"
SPEED_MULTIPLIER = 1
EPOS_UPDATE_INTERVAL = 0.1
FRAME_QUEUE_LIMIT = 5

# Acceleration and deceleration defaults
DEFAULT_ACCELERATION = 32750
DEFAULT_DECELERATION = 32750

# Globals
picam2 = None
controller = None
axis = None
demo_running = False
frame_queue = deque(maxlen=FRAME_QUEUE_LIMIT)
last_control_activity = time.time()
last_global_activity = time.time()
control_connection_healthy = False
shutdown_requested = False
circuit_breaker_failures = 0
circuit_breaker_threshold = 3
circuit_breaker_cooldown = 0
circuit_breaker_cooldown_period = 30  # seconds
last_ping_times = []
ping_history_limit = 10
critical_message_queue = deque(maxlen=100)

# Functions for connection monitoring and stability
def print_debug_status():
    """Print detailed debug information about connection state."""
    global last_control_activity, last_global_activity, control_connection_healthy
    current_time = time.time()
    control_silence = current_time - last_control_activity
    global_inactivity = current_time - last_global_activity
    
    logger.debug(f"CONNECTION STATUS: control_healthy={control_connection_healthy}, "
                f"control_silence={control_silence:.1f}s, "
                f"global_inactivity={global_inactivity:.1f}s")

def update_activity_timestamps():
    """Update all activity timestamps to prevent false watchdog triggers."""
    global last_control_activity, last_global_activity
    current_time = time.time()
    last_control_activity = current_time
    last_global_activity = current_time
    logger.debug("Activity timestamps updated")

def circuit_breaker_check():
    """Implements a circuit breaker pattern to prevent rapid reconnection attempts."""
    global circuit_breaker_failures, circuit_breaker_cooldown
    
    current_time = time.time()
    
    # If in cooldown, check if cooldown period has passed
    if circuit_breaker_cooldown > 0:
        if current_time < circuit_breaker_cooldown:
            return False  # Still in cooldown, don't attempt reconnection
        circuit_breaker_cooldown = 0  # Cooldown finished
    
    # If threshold exceeded, enter cooldown
    if circuit_breaker_failures >= circuit_breaker_threshold:
        logger.warning(f"Circuit breaker tripped after {circuit_breaker_failures} failures")
        circuit_breaker_cooldown = current_time + circuit_breaker_cooldown_period
        circuit_breaker_failures = 0
        return False
    
    return True  # Ok to proceed with connection attempt

def monitor_connection_quality():
    """Monitor and report connection quality based on ping times."""
    global last_ping_times
    
    if len(last_ping_times) < 2:
        return None
        
    avg_ping = sum(last_ping_times) / len(last_ping_times)
    jitter = max(abs(t - avg_ping) for t in last_ping_times)
    
    quality = "good"
    if avg_ping > 200:  # High latency
        quality = "poor"
    elif jitter > 50:  # High jitter
        quality = "unstable"
        
    logger.info(f"Connection quality: {quality} (avg_ping={avg_ping:.1f}ms, jitter={jitter:.1f}ms)")
    return quality

def queue_critical_message(message):
    """Queue critical messages to ensure delivery."""
    critical_message_queue.append(message)
    logger.debug(f"Message queued. Queue size: {len(critical_message_queue)}")

async def process_message_queue(websocket):
    """Process and send queued critical messages."""
    if not critical_message_queue:
        return
        
    logger.info(f"Processing {len(critical_message_queue)} queued messages")
    
    while critical_message_queue:
        try:
            message = critical_message_queue.popleft()
            await websocket.send(json.dumps(message))
            logger.debug("Sent queued message")
            await asyncio.sleep(0.1)  # Brief pause between messages
        except Exception as e:
            logger.error(f"Error sending queued message: {str(e)}")
            # Put the message back in queue if send fails
            critical_message_queue.appendleft(message)
            break

async def reset_network_if_needed():
    """Check network connectivity and reset if needed."""
    try:
        # Check if we can reach the server's domain
        server_domain = SERVER_URL.split('/')[2].split(':')[0]
        result = subprocess.run(['ping', '-c', '1', '-W', '2', server_domain], 
                                capture_output=True, text=True)
        
        if result.returncode != 0:
            logger.warning(f"Cannot ping server domain {server_domain}, resetting WiFi")
            # This only works if the RPi is configured to allow passwordless sudo for these commands
            subprocess.run(['sudo', 'ip', 'link', 'set', 'wlan0', 'down'], check=False)
            await asyncio.sleep(2)
            subprocess.run(['sudo', 'ip', 'link', 'set', 'wlan0', 'up'], check=False)
            logger.info("WiFi interface reset attempted")
            await asyncio.sleep(5)  # Wait for network to initialize
            return True
    except Exception as e:
        logger.error(f"Error checking/resetting network: {str(e)}")
    
    return False

# Camera Functions
def initialize_camera():
    """Initialize camera with retry logic."""
    global picam2
    retries = 0
    while retries < MAX_RETRIES:
        try:
            logger.info("Initializing camera")
            picam2 = Picamera2()
            config = picam2.create_video_configuration(main={"size": (RESOLUTION_WIDTH, RESOLUTION_HEIGHT), "format": "RGB888"})
            picam2.configure(config)
            picam2.start()
            logger.info(f"Camera initialized: {RESOLUTION_WIDTH}x{RESOLUTION_HEIGHT}")
            time.sleep(1)
            return True
        except Exception as e:
            retries += 1
            logger.error(f"Camera init failed ({retries}/{MAX_RETRIES}): {str(e)}")
            stop_camera(picam2)
            picam2 = None
            gc.collect()
            time.sleep(RETRY_DELAY)
    logger.error(f"Camera init failed after {MAX_RETRIES} retries")
    return False

def stop_camera(cam):
    """Safely stop and close camera."""
    try:
        if cam:
            if hasattr(cam, 'started') and cam.started:
                cam.stop()
                logger.info("Camera stopped")
            for _ in range(3):
                try:
                    cam.close()
                    logger.info("Camera closed")
                    break
                except Exception as e:
                    logger.warning(f"Camera close retry failed: {str(e)}")
                    time.sleep(0.1)
    except Exception as e:
        logger.error(f"Error stopping camera: {str(e)}")
    finally:
        gc.collect()

def reset_camera_stack():
    """Soft reset camera."""
    try:
        logger.info("Soft resetting camera")
        stop_camera(picam2)
        time.sleep(1)
        logger.info("Camera reset complete")
    except Exception as e:
        logger.error(f"Reset failed: {str(e)}")

# Function to set acceleration and deceleration parameters
def set_acce_dece_params(acce_value=None, dece_value=None):
    """Set acceleration and deceleration parameters."""
    global axis
    if not axis:
        logger.error("Cannot set acce/dece: Axis not initialized")
        return False
    
    try:
        if acce_value is not None:
            # Ensure acce_value is within valid range (0-65500)
            acce_value = max(0, min(65500, int(acce_value)))
            axis.sendCommand(f"ACCE={acce_value}")
            logger.info(f"Set acceleration to {acce_value}")
        
        if dece_value is not None:
            # Ensure dece_value is within valid range (0-65500)
            dece_value = max(0, min(65500, int(dece_value)))
            axis.sendCommand(f"DECE={dece_value}")
            logger.info(f"Set deceleration to {dece_value}")
        
        return True
    except Exception as e:
        logger.error(f"Error setting acce/dece: {str(e)}")
        return False

# Xeryon Functions
def initialize_xeryon_controller():
    """Initialize Xeryon with robust serial retry."""
    global controller, axis
    retries = 0
    while retries < MAX_RETRIES:
        try:
            if not os.path.exists(COM_PORT):
                logger.warning(f"{COM_PORT} not foundâattempting USB reset")
                subprocess.run(["usbreset", COM_PORT], check=False)
                time.sleep(1)
                if not os.path.exists(COM_PORT):
                    raise serial.SerialException(f"{COM_PORT} still missing")
            logger.info(f"Initializing Xeryon on {COM_PORT}")
            with serial.Serial(COM_PORT, 115200, timeout=1) as ser:
                ser.reset_input_buffer()
                ser.reset_output_buffer()
            controller = Xeryon(COM_port=COM_PORT, baudrate=115200)
            axis = controller.addAxis(Stage.XLA_312_3N, "X")
            controller.start()
            axis.setUnits(Units.mm)
            axis.sendCommand("POLI=50")
            axis.findIndex()
            
            # Set default speed, acceleration, and deceleration
            base_speed = 500
            multiplied_speed = base_speed * SPEED_MULTIPLIER
            axis.setSpeed(multiplied_speed)
            set_acce_dece_params(DEFAULT_ACCELERATION, DEFAULT_DECELERATION)
            
            logger.info(f"Xeryon initialized with speed={multiplied_speed}, acce={DEFAULT_ACCELERATION}, dece={DEFAULT_DECELERATION}")
            return True
        except Exception as e:
            retries += 1
            logger.error(f"Xeryon init failed ({retries}/{MAX_RETRIES}): {str(e)}")
            if controller:
                stop_controller(controller)
                controller = None
                axis = None
            time.sleep(RETRY_DELAY)
    logger.error(f"Xeryon init failed after {MAX_RETRIES} retries")
    return False

def stop_controller(ctrl):
    """Safely stop Xeryon."""
    try:
        if ctrl:
            ctrl.stop()
            logger.info("Controller stopped")
    except Exception as e:
        logger.error(f"Error stopping controller: {str(e)}")

async def run_demo():
    """Run Xeryon demo."""
    global demo_running, axis
    demo_running = True
    logger.info("Demo started")
    for _ in range(100):
        if not demo_running or not axis:
            break
        try:
            speed = random.uniform(10, 500)
            await asyncio.to_thread(axis.setSpeed, speed)
            logger.info(f"Demo: Speed {speed} mm/s")
            action = random.choice(["step", "scan"])
            if action == "step":
                direction = random.choice([1, -1])
                await asyncio.to_thread(axis.step, direction)
                logger.info(f"Demo: Step {direction} mm")
                await asyncio.sleep(0.5)
            else:
                direction = random.choice([1, -1])
                await asyncio.to_thread(axis.startScan, direction)
                logger.info(f"Demo: Scan {'right' if direction == 1 else 'left'}")
                await asyncio.sleep(random.uniform(0.5, 2))
                await asyncio.to_thread(axis.stopScan)
                logger.info("Demo: Scan stopped")
        except Exception as e:
            logger.error(f"Demo error: {str(e)}")
            demo_running = False
            break
    if demo_running:
        logger.info("Demo completed")
        try:
            await asyncio.to_thread(axis.setDPOS, 0)
            logger.info("Demo: DPOS 0 mm")
        except Exception as e:
            logger.error(f"DPOS reset error: {str(e)}")
    demo_running = False

async def process_command(data):
    """Handle Xeryon commands and pings."""
    global demo_running, axis, last_control_activity, last_global_activity, last_ping_times
    
    # Update both activity timestamps for ANY command or message
    update_activity_timestamps()
    
    message_type = data.get("type")
    command = data.get("command", "unknown")
    direction = data.get("direction", "none")
    step_size = data.get("stepSize")
    step_unit = data.get("stepUnit")
    timestamp = data.get("timestamp")
    
    # Handle both old and new parameter names for acceleration and deceleration
    acce_value = data.get("acceleration")
    if acce_value is None:
        acce_value = data.get("acce")
    
    dece_value = data.get("deceleration")
    if dece_value is None:
        dece_value = data.get("dece")
    
    logger.debug(f"COMMAND RECEIVED: {command}, acce: {acce_value}, dece: {dece_value}")
    
    response = {"status": "success", "rpiId": STATION_ID}

    try:
        # Handle ping/pong messages for latency measurements
        if message_type == "ping":
            response.update({
                "type": "pong",
                "timestamp": timestamp,
                "rpiId": STATION_ID
            })
            logger.info(f"Replied to ping with pong, timestamp: {timestamp}")
            return response
        elif message_type == "pong":
            if timestamp:
                ping_time = datetime.fromisoformat(timestamp)
                pong_time = datetime.now()
                latency_ms = (pong_time - ping_time).total_seconds() * 1000
                logger.info(f"Ping-pong latency: {latency_ms:.2f}ms")
                
                # Track ping times for quality monitoring
                last_ping_times.append(latency_ms)
                if len(last_ping_times) > ping_history_limit:
                    last_ping_times.pop(0)
                
                # Check connection quality periodically
                if len(last_ping_times) >= ping_history_limit:
                    monitor_connection_quality()
            logger.info(f"Received pong, timestamp: {timestamp}")
            return None
        elif message_type == "heartbeat":
            # Special heartbeat message to detect control connection health
            response.update({
                "type": "heartbeat_response",
                "timestamp": datetime.now().isoformat(),
                "status": "healthy",
                "rpiId": STATION_ID
            })
            return response

        if not axis:
            raise Exception("Axis not initializedâcannot process command")
        
        response["message"] = f"Executing command '{command}'"
        logger.info(f"Processing command: {command}, direction: {direction}, stepSize: {step_size}, stepUnit: {step_unit}, acce: {acce_value}, dece: {dece_value}")
        
        # Handle acceleration and deceleration commands directly
        if command in ["acceleration", "acce"]:
            if acce_value is None:
                acce_value = int(direction) if direction.isdigit() else DEFAULT_ACCELERATION
            set_acce_dece_params(acce_value=acce_value)
            response["message"] = f"Acceleration set to {acce_value}"
            return response
            
        elif command in ["deceleration", "dece"]:
            if dece_value is None:
                dece_value = int(direction) if direction.isdigit() else DEFAULT_DECELERATION
            set_acce_dece_params(dece_value=dece_value)
            response["message"] = f"Deceleration set to {dece_value}"
            return response
            
        # Set acce/dece parameters for all commands if provided
        if acce_value is not None or dece_value is not None:
            set_acce_dece_params(acce_value, dece_value)
            if acce_value is not None:
                response["acceleration"] = acce_value
            if dece_value is not None:
                response["deceleration"] = dece_value
        
        if command in ["move", "step"]:
            if direction not in ["right", "left"]:
                raise ValueError(f"Invalid direction: {direction}")
            if step_size is None or not isinstance(step_size, (int, float)) or step_size < 0:
                raise ValueError(f"Invalid stepSize: {step_size}")
            if step_unit not in ["mm", "Âµm", "nm"]:
                raise ValueError(f"Invalid stepUnit: {step_unit}")
            step_value = float(step_size)
            if step_unit == "Âµm":
                step_value /= 1000
            elif step_unit == "nm":
                step_value /= 1_000_000
            final_step = step_value if direction == "right" else -step_value
            await asyncio.to_thread(axis.step, final_step)
            response["message"] = f"Stepped {final_step:.6f} mm {'right' if direction == 'right' else 'left'}"
            response["step_executed_mm"] = final_step
            logger.info(f"Move executed: {final_step:.6f} mm")
        
        elif command == "home":
            await asyncio.to_thread(axis.findIndex)
            epos = await asyncio.to_thread(axis.getEPOS)
            response["message"] = f"Homed to index, EPOS {epos:.6f} mm"
            response["epos_mm"] = epos
            logger.info(f"Homed, EPOS: {epos:.6f} mm")
        
        elif command == "speed":
            speed_value = float(direction)
            multiplied_speed = speed_value * SPEED_MULTIPLIER
            await asyncio.to_thread(axis.setSpeed, multiplied_speed)
            response["message"] = f"Speed set to {multiplied_speed:.2f} mm/s"
            logger.info(f"Speed set: {multiplied_speed:.2f} mm/s")
        
        elif command == "scan":
            if direction == "right":
                await asyncio.to_thread(axis.startScan, 1)
                response["message"] = "Scanning right"
            elif direction == "left":
                await asyncio.to_thread(axis.startScan, -1)
                response["message"] = "Scanning left"
            else:
                raise ValueError(f"Invalid scan direction: {direction}")
            logger.info(f"Scan started: {direction}")
        
        elif command == "demo_start":
            if not demo_running:
                asyncio.create_task(run_demo())
                response["message"] = "Demo started"
                logger.info("Demo started")
            else:
                response["message"] = "Demo already running"
                logger.info("Demo already running")
        
        elif command == "demo_stop":
            if demo_running:
                demo_running = False
                await asyncio.to_thread(axis.stopScan)
                await asyncio.to_thread(axis.setDPOS, 0)
                response["message"] = "Demo stopped, DPOS 0 mm"
                logger.info("Demo stopped, DPOS 0 mm")
            else:
                response["message"] = "No demo running"
                logger.info("No demo running")
        
        elif command == "stop":
            await asyncio.to_thread(axis.stopScan)
            await asyncio.to_thread(axis.setDPOS, 0)
            response["message"] = "Stopped, DPOS 0 mm"
            logger.info("Stopped, DPOS 0 mm")
        
        elif command == "reset_params":
            # Reset to default parameters
            multiplied_speed = 500 * SPEED_MULTIPLIER  # Default speed
            await asyncio.to_thread(axis.setSpeed, multiplied_speed)
            set_acce_dece_params(DEFAULT_ACCELERATION, DEFAULT_DECELERATION)
            response["message"] = f"Parameters reset to defaults: speed={multiplied_speed}, acce={DEFAULT_ACCELERATION}, dece={DEFAULT_DECELERATION}"
            logger.info(f"Parameters reset to defaults")
        
        else:
            raise ValueError(f"Unknown command: {command}")
    
    except Exception as e:
        response["status"] = "error"
        response["message"] = f"Command '{command}' failed: {str(e)}"
        logger.error(f"Command error: {str(e)}")
    
    return response

# WebSocket Tasks
async def camera_feed():
    """Stream camera frames."""
    global picam2, frame_queue, last_global_activity, circuit_breaker_failures
    session_retries = 0
    connection_id = f"camera_{int(time.time())}"
    
    while not shutdown_requested:
        try:
            if session_retries >= SESSION_RETRIES:
                logger.error(f"Hit {SESSION_RETRIES} camera retries - resetting camera")
                reset_camera_stack()
                session_retries = 0

            if not picam2 or not hasattr(picam2, 'started') or not picam2.started:
                if not initialize_camera():
                    session_retries += 1
                    logger.error(f"Camera retry {session_retries}/{SESSION_RETRIES}")
                    await asyncio.sleep(RETRY_DELAY)
                    continue

            # Check circuit breaker before connection attempt
            if not circuit_breaker_check():
                logger.warning("Circuit breaker preventing camera connection attempt")
                # Try to reset network if in circuit breaker cooldown
                await reset_network_if_needed()
                await asyncio.sleep(RETRY_DELAY * 2)
                continue

            # Use a unique URL with connection type to avoid connection conflicts
            camera_url = f"{SERVER_URL}?type=camera&id={connection_id}"
            logger.debug(f"Connecting to camera WebSocket at {camera_url}")
            
            # Simple connection without custom ping settings
            async with websockets.connect(camera_url, ping_interval=None) as websocket:
                # Send clear registration with connectionType
                await websocket.send(json.dumps({
                    "type": "register",
                    "status": "ready",
                    "connectionType": "camera",  # Explicitly identify this as camera connection
                    "message": f"RPi {STATION_ID} camera online",
                    "rpiId": STATION_ID
                }))
                
                logger.info(f"Camera WebSocket connected: {camera_url}")
                update_activity_timestamps()
                last_frame_time = time.time()
                frame_count = 0
                EPOS_interval = 0
                
                # Reset circuit breaker on successful connection
                circuit_breaker_failures = 0
                
                # Start application-level ping loop
                async def ping_loop():
                    """Send application-level pings instead of WebSocket-level pings."""
                    while not shutdown_requested:
                        try:
                            ping_data = {
                                "type": "ping", 
                                "timestamp": datetime.now().isoformat(),
                                "rpiId": STATION_ID
                            }
                            await websocket.send(json.dumps(ping_data))
                            logger.debug("Sent application-level ping on camera connection")
                            await asyncio.sleep(1)  # Send ping every second
                        except Exception as e:
                            logger.error(f"Camera ping loop error: {str(e)}")
                            break
                
                ping_task = asyncio.create_task(ping_loop())
                
                # Process any queued messages
                await process_message_queue(websocket)

                while not shutdown_requested:
                    # Get a camera frame and compress it
                    try:
                        current_time = time.time()
                        frame_interval = 1.0 / TARGET_FPS
                        elapsed = current_time - last_frame_time
                        
                        # Rate limit frame sending to target FPS
                        if elapsed < frame_interval:
                            await asyncio.sleep(frame_interval - elapsed)
                        
                        last_frame_time = time.time()
                        rgb_buffer = picam2.capture_array("main")
                        frame = cv2.cvtColor(rgb_buffer, cv2.COLOR_RGB2BGR)
                        
                        # Get timestamp for this frame
                        frame_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
                        
                        # Add ID number and timestamp to frame
                        id_string = f"RPI: {STATION_ID} - Frame: {frame_count} - {frame_time}"
                        cv2.putText(frame, id_string, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                        
                        # Encode and compress the frame
                        encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY]
                        _, buffer = cv2.imencode('.jpg', frame, encode_param)
                        jpg_as_text = base64.b64encode(buffer).decode('utf-8')
                        
                        # Create and send the frame data
                        frame_data = {
                            "type": "camera_frame", 
                            "rpiId": STATION_ID,
                            "frame": jpg_as_text,
                            "frameCount": frame_count,
                            "timestamp": frame_time,
                            "frameFormat": "jpg.base64"
                        }
                        await websocket.send(json.dumps(frame_data))
                        frame_count += 1
                        
                        # Update activity timestamp after successful frame send
                        last_global_activity = time.time()
                        
                        # Get EPOS value and send it separately
                        EPOS_interval += elapsed
                        if axis and EPOS_interval >= EPOS_UPDATE_INTERVAL:
                            try:
                                epos = await asyncio.to_thread(axis.getEPOS)
                                epos_data = {
                                    "type": "position_update",
                                    "rpiId": STATION_ID,
                                    "epos": round(epos, 3),
                                    "timestamp": datetime.now().isoformat()
                                }
                                await websocket.send(json.dumps(epos_data))
                                EPOS_interval = 0
                                
                                # Update activity timestamp after successful position update
                                last_global_activity = time.time()
                            except Exception as e:
                                logger.error(f"Error getting EPOS: {str(e)}")
                    
                    except Exception as e:
                        logger.error(f"Error capturing/sending frame: {str(e)}")
                        session_retries += 1
                        if session_retries >= SESSION_RETRIES:
                            logger.error("Max frame errors reached, resetting camera")
                            break
                        await asyncio.sleep(0.1)
                        continue
                    
                    # Process any incoming messages from server
                    try:
                        message = await asyncio.wait_for(websocket.recv(), 0.01)
                        try:
                            data = json.loads(message)
                            # Update activity timestamp when receiving any message
                            last_global_activity = time.time()
                            
                            if data.get("type") == "pong":
                                ping_time = datetime.fromisoformat(data.get("timestamp"))
                                pong_time = datetime.now()
                                latency_ms = (pong_time - ping_time).total_seconds() * 1000
                                logger.info(f"Ping-pong latency: {latency_ms:.2f}ms")
                                
                                # Track ping times for quality monitoring
                                last_ping_times.append(latency_ms)
                                if len(last_ping_times) > ping_history_limit:
                                    last_ping_times.pop(0)
                        except json.JSONDecodeError:
                            logger.warning(f"Received invalid JSON on camera connection: {message[:100]}...")
                    except asyncio.TimeoutError:
                        pass  # No messages to process
                    except Exception as e:
                        logger.error(f"Error processing camera message: {str(e)}")
                        break
                
                # Clean up ping task
                if ping_task and not ping_task.done():
                    ping_task.cancel()
                    try:
                        await ping_task
                    except asyncio.CancelledError:
                        pass
                
        except Exception as e:
            logger.error(f"Camera feed connection error: {str(e)}")
            circuit_breaker_failures += 1
        
        if not shutdown_requested:
            logger.info(f"Camera feed disconnected, reconnecting in {RETRY_DELAY}s...")
            await asyncio.sleep(RETRY_DELAY)
            # Use a new connection ID for reconnect attempts
            connection_id = f"camera_{int(time.time())}"

# Watchdog for connection monitoring
async def connection_watchdog():
    """Monitor and restart stalled connections."""
    global last_control_activity, control_connection_healthy, last_global_activity, shutdown_requested
    
    CONTROL_HEARTBEAT_INTERVAL = 5
    MAX_CONTROL_SILENCE = 15
    GLOBAL_ACTIVITY_TIMEOUT = 600  # 10 minutes
    
    logger.info("Starting connection watchdog")
    
    while not shutdown_requested:
        try:
            print_debug_status()  # Log detailed status info
            current_time = time.time()
            
            # Check control connection health
            control_silence = current_time - last_control_activity
            if control_silence > MAX_CONTROL_SILENCE and control_connection_healthy:
                logger.warning(f"Control connection silent for {control_silence:.1f}s")
                if control_silence > MAX_CONTROL_SILENCE * 2:
                    logger.error(f"Control connection non-responsive for {control_silence:.1f}s, marking unhealthy")
                    control_connection_healthy = False
            
            # Only check for global activity timeout if both camera and position data have stopped
            global_inactivity = current_time - last_global_activity
            if global_inactivity > GLOBAL_ACTIVITY_TIMEOUT / 2:
                logger.warning(f"No system activity for {global_inactivity:.1f}s (limit: {GLOBAL_ACTIVITY_TIMEOUT}s)")
                
                # Only trigger system reset after extended complete inactivity and if camera exists
                if global_inactivity > GLOBAL_ACTIVITY_TIMEOUT and picam2:
                    logger.error(f"System inactive for {global_inactivity:.1f}s, restarting camera")
                    reset_camera_stack()
                    # Reset activity timestamps after camera restart
                    update_activity_timestamps()
            
            await asyncio.sleep(5)  # Check every 5 seconds
            
        except Exception as e:
            logger.error(f"Watchdog error: {str(e)}")
            await asyncio.sleep(10)  # Longer delay if watchdog fails

# Resource monitoring and cleanup
async def resource_cleanup():
    """Periodic cleanup of memory and resources."""
    while not shutdown_requested:
        try:
            # Force garbage collection
            collected = gc.collect()
            logger.debug(f"Garbage collection: {collected} objects")
            
            try:
                # This part requires psutil which may not be installed
                import psutil
                process = psutil.Process(os.getpid())
                memory_info = process.memory_info()
                logger.debug(f"Memory usage: {memory_info.rss / 1024 / 1024:.1f} MB")
            except ImportError:
                # Just log available memory from /proc if psutil not available
                try:
                    with open('/proc/meminfo', 'r') as f:
                        for line in f:
                            if 'MemAvailable' in line:
                                available = int(line.split()[1]) / 1024  # Convert KB to MB
                                logger.debug(f"Available system memory: {available:.1f} MB")
                                break
                except:
                    pass
            
            await asyncio.sleep(60)  # Run every minute
        except Exception as e:
            logger.error(f"Resource cleanup error: {str(e)}")
            await asyncio.sleep(120)  # Longer delay if error

# Control connection manager
async def control_connection_manager():
    """Manage the control connection with improved stability."""
    global last_control_activity, control_connection_healthy, shutdown_requested, circuit_breaker_failures
    connection_id = f"control_{int(time.time())}"
    heartbeat_task = None
    
    while not shutdown_requested:
        try:
            # Check circuit breaker before connection attempt
            if not circuit_breaker_check():
                logger.warning("Circuit breaker preventing control connection attempt")
                # Try to reset network if in circuit breaker cooldown
                await reset_network_if_needed()
                await asyncio.sleep(RETRY_DELAY * 2)
                continue
                
            # Use a distinct URL for the control connection
            control_url = f"{SERVER_URL}?type=control&id={connection_id}"
            
            logger.info(f"Establishing control connection to {control_url}")
            
            # Simple connection without custom ping settings
            async with websockets.connect(control_url, ping_interval=None) as websocket:
                # Send registration with connectionType
                await websocket.send(json.dumps({
                    "type": "register",
                    "connectionType": "control",  # Explicitly identify as control connection
                    "message": f"RPi {STATION_ID} control ready",
                    "rpiId": STATION_ID
                }))
                logger.info(f"Control WebSocket connected: {control_url}")
                
                # Update activity timestamp when connection established
                update_activity_timestamps()
                control_connection_healthy = True
                
                # Reset circuit breaker on successful connection
                circuit_breaker_failures = 0
                
                # Process any queued messages
                await process_message_queue(websocket)
                
                # Start heartbeat task
                async def heartbeat_loop():
                    """Send regular heartbeats to keep connection alive."""
                    heartbeat_count = 0
                    while not shutdown_requested:
                        try:
                            # Alternate between different message types to ensure compatibility
                            if heartbeat_count % 3 == 0:
                                heartbeat_data = {
                                    "type": "heartbeat",
                                    "timestamp": datetime.now().isoformat(),
                                    "rpiId": STATION_ID
                                }
                                await websocket.send(json.dumps(heartbeat_data))
                                logger.debug("Sent control connection heartbeat")
                            else:
                                ping_data = {
                                    "type": "ping", 
                                    "timestamp": datetime.now().isoformat(),
                                    "rpiId": STATION_ID
                                }
                                await websocket.send(json.dumps(ping_data))
                                logger.debug("Sent application-level ping on control connection")
                            
                            # Update activity timestamp on successful heartbeat
                            last_control_activity = time.time()
                            heartbeat_count += 1
                            await asyncio.sleep(1)  # Send a heartbeat every second
                        except Exception as e:
                            logger.error(f"Heartbeat error: {str(e)}")
                            break
                
                heartbeat_task = asyncio.create_task(heartbeat_loop())
                
                # Process incoming commands
                while not shutdown_requested:
                    # Check if control connection has been silent too long
                    current_time = time.time()
                    if current_time - last_control_activity > 15:  # 15 seconds max silence
                        logger.warning(f"Control connection inactive for {current_time - last_control_activity:.1f}s, forcing reconnect")
                        break
                    
                    try:
                        # Use a short timeout to prevent blocking
                        message = await asyncio.wait_for(websocket.recv(), 1.0)
                        try:
                            data = json.loads(message)
                            logger.debug(f"Received control message: {data.get('type', 'unknown')}")
                            
                            # Process the command and get a response
                            response = await process_command(data)
                            
                            # Only send a response if we got one back
                            if response:
                                response["type"] = "rpi_response" if "type" not in response else response["type"]
                                await websocket.send(json.dumps(response))
                                logger.debug(f"Sent response: {response.get('message', '')}")
                        except json.JSONDecodeError:
                            logger.warning(f"Received invalid JSON on control connection: {message[:100]}...")
                    except asyncio.TimeoutError:
                        # No messages received within timeout, continue
                        pass
                    except Exception as e:
                        logger.error(f"Error processing control message: {str(e)}")
                        # Try to send error response
                        try:
                            error_response = {
                                "type": "rpi_response",
                                "status": "error",
                                "message": f"Error: {str(e)}",
                                "rpiId": STATION_ID
                            }
                            await websocket.send(json.dumps(error_response))
                        except:
                            pass
                        break
                
                # Clean up heartbeat task when connection ends
                if heartbeat_task and not heartbeat_task.done():
                    heartbeat_task.cancel()
                    try:
                        await heartbeat_task
                    except asyncio.CancelledError:
                        pass
                
        except Exception as e:
            logger.error(f"Control connection error: {str(e)}")
            control_connection_healthy = False
            circuit_breaker_failures += 1
        
        if not shutdown_requested:
            logger.info(f"Control connection disconnected, reconnecting in {RETRY_DELAY}s...")
            await asyncio.sleep(RETRY_DELAY)
            # Reconnect with a new ID to ensure clean connection
            connection_id = f"control_{int(time.time())}"

async def main():
    """Main entry point to run the RPI client."""
    global shutdown_requested, control_connection_healthy
    
    try:
        # Initialize hardware
        logger.info(f"Starting RPi Client for {STATION_ID}")
        logger.info(f"Connecting to server: {SERVER_URL}")
        logger.info("Initializing hardware...")
        
        # Initialize Xeryon controller
        if not initialize_xeryon_controller():
            logger.error("Failed to initialize Xeryon controller")
            # Continue anyway to allow camera functions
        
        # Initialize camera
        if not initialize_camera():
            logger.error("Failed to initialize camera")
            # Continue anyway to allow Xeryon functions
        
        # Set control_connection_healthy to False initially
        control_connection_healthy = False
        
        # Start the camera and control connection tasks, along with the watchdog
        camera_task = asyncio.create_task(camera_feed())
        control_task = asyncio.create_task(control_connection_manager())
        watchdog_task = asyncio.create_task(connection_watchdog())
        cleanup_task = asyncio.create_task(resource_cleanup())
        
        # Wait for all tasks to complete
        await asyncio.gather(camera_task, control_task, watchdog_task, cleanup_task)
        
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt received, shutting down...")
        shutdown_requested = True
    except Exception as e:
        logger.error(f"Fatal error in main: {str(e)}")
    finally:
        # Clean shutdown of resources
        shutdown_requested = True
        logger.info("Shutting down...")
        if axis:
            try:
                # Issue stop command to ensure motor stops moving
                if axis:
                    axis.stopScan()
                    logger.info("Motor stopped")
            except:
                pass
        stop_controller(controller)
        stop_camera(picam2)
        logger.info("Shutdown complete")

if __name__ == "__main__":
    # Get RPi ID from command line if provided
    if len(sys.argv) > 1:
        STATION_ID = sys.argv[1]
        logger.info(f"Using command line RPi ID: {STATION_ID}")
    
    # Run the main function
    asyncio.run(main())
